import re
import os
import matplotlib
matplotlib.use('Agg')  # Non-interactive backend to prevent GUI errors on server
import matplotlib.pyplot as plt

def analyze_gcode(gcode_path):
    """
    Analysiert eine G-Code-Datei umfassend.
    Liest zuerst die effizienten Header-Kommentare von PrusaSlicer
    und durchsucht dann die gesamte Datei für detailliertere Metriken.
    """
    results = {
        'print_time_min': 0,
        'filament_used_mm': 0.0,
        'filament_used_g': 0.0,
        'tool_changes': 0,
        'layer_count': 0,
        'width_mm': 0.0,
        'depth_mm': 0.0,
        'filament_per_tool': {},
        'material_type': None,
        'layer_height_mm': None
    }

    # 1. PrusaSlicer Header-Kommentare auslesen (schnell & effizient)
    try:
        with open(gcode_path, 'r', encoding='utf-8') as f:
            for line in f:
                if line.startswith('; generated by PrusaSlicer'):
                    continue # Header beginnt hier

                if '; estimated printing time' in line:
                    hours_match = re.search(r'(\d+)h', line)
                    mins_match = re.search(r'(\d+)m', line)
                    secs_match = re.search(r'(\d+)s', line)
                    hours = int(hours_match.group(1)) if hours_match else 0
                    mins = int(mins_match.group(1)) if mins_match else 0
                    results['print_time_min'] = (hours * 60) + mins
                
                if '; filament used [g]' in line:
                    match = re.search(r'([\d\.]+)', line)
                    if match:
                        results['filament_used_g'] = float(match.group(0))
                
                if '; filament used [mm]' in line:
                    match = re.search(r'([\d\.]+)', line)
                    if match:
                        results['filament_used_mm'] = float(match.group(0))

                if '; layer_height = ' in line:
                    match = re.search(r'[\d\.]+', line)
                    if match:
                        results['layer_height_mm'] = float(match.group(0))
                
                if '; filament_type = ' in line:
                    match = re.search(r'=\s*(.*)', line)
                    if match:
                        results['material_type'] = match.group(1).strip()

                if line.startswith('M73 P0'): # Ende des Headers oft hier
                    break
    except (IOError, UnicodeDecodeError):
        pass

    # 2. Komplette Datei für zusätzliche Metriken parsen
    min_x, max_x = float('inf'), float('-inf')
    min_y, max_y = float('inf'), float('-inf')
    layer_z_values = set()
    current_tool = 0
    filament_per_tool = {}
    first_extrusion_found = False

    try:
        with open(gcode_path, 'r', encoding='utf-8') as f:
            for line in f:
                line_upper = line.strip().upper()
                
                if line_upper.startswith('T'):
                    tool_match = re.match(r'T(\d+)', line_upper)
                    if tool_match:
                        current_tool = int(tool_match.group(1))
                
                if line_upper.startswith(('G1', 'G0')):
                    e_match = re.search(r'E([\d\.-]+)', line_upper)
                    
                    # Beginne Bounding-Box-Berechnung erst bei der ersten echten Extrusion
                    if e_match and float(e_match.group(1)) > 0:
                        if not first_extrusion_found:
                            first_extrusion_found = True
                            # Reset der Koordinaten, um initiale Fahrten zu ignorieren
                            min_x, max_x = float('inf'), float('-inf')
                            min_y, max_y = float('inf'), float('-inf')

                        x_match = re.search(r'X([\d\.]+)', line_upper)
                        y_match = re.search(r'Y([\d\.]+)', line_upper)
                        if x_match:
                            x = float(x_match.group(1))
                            min_x, max_x = min(min_x, x), max(max_x, x)
                        if y_match:
                            y = float(y_match.group(1))
                            min_y, max_y = min(min_y, y), max(max_y, y)
                            
                        # Filament pro Werkzeug
                        extrusion = float(e_match.group(1))
                        filament_per_tool[current_tool] = filament_per_tool.get(current_tool, 0) + extrusion

                    # Zähle Layer-Wechsel auch bei reinen Fahrten
                    z_match = re.search(r'Z([\d\.]+)', line_upper)
                    if z_match:
                        layer_z_values.add(float(z_match.group(1)))
                            
    except (IOError, UnicodeDecodeError) as e:
        print(f"Fehler beim Parsen der G-Code-Datei {gcode_path}: {e}")
        return results

    # 3. Ergebnisse finalisieren
    if min_x != float('inf'):
        results['width_mm'] = round(max_x - min_x, 2)
        results['depth_mm'] = round(max_y - min_y, 2)
    
    results['layer_count'] = len(layer_z_values)
    results['tool_changes'] = max(0, len(filament_per_tool) - 1) if len(filament_per_tool) > 1 else 0
    results['filament_per_tool'] = filament_per_tool

    return results


def create_gcode_preview(gcode_path, output_path, max_lines=100000):
    x_coords, y_coords = [], []
    current_x, current_y = 0, 0
    line_count = 0

    try:
        with open(gcode_path, 'r', encoding='utf-8') as f:
            for line in f:
                line_count += 1
                if line_count > max_lines:
                    break
                    
                if line.startswith('G1') or line.startswith('G0'):
                    if 'E' in line and not 'E-' in line:
                        x_match = re.search(r'X([\d\.]+)', line)
                        y_match = re.search(r'Y([\d\.]+)', line)
                        
                        if x_match:
                            current_x = float(x_match.group(1))
                        if y_match:
                            current_y = float(y_match.group(1))

                        if x_match or y_match:
                            x_coords.append(current_x)
                            y_coords.append(current_y)
    except (IOError, UnicodeDecodeError) as e:
        print(f"Fehler beim Lesen der G-Code-Datei für die Vorschau {gcode_path}: {e}")
        return False

    if not x_coords or not y_coords:
        return False

    plt.figure(figsize=(8, 8))
    plt.plot(x_coords, y_coords, color='#3498db', linewidth=0.5)
    plt.title('G-Code Werkzeugpfad-Vorschau')
    plt.xlabel('X-Achse (mm)')
    plt.ylabel('Y-Achse (mm)')
    plt.axis('equal')
    plt.grid(True)
    
    try:
        plt.savefig(output_path, format='png', bbox_inches='tight')
    except IOError as e:
        print(f"Fehler beim Speichern des Vorschau-Bildes nach {output_path}: {e}")
        return False
    finally:
        plt.close()

    return True

